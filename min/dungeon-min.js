const buildDungeon=([e,a])=>{walkableTiles=0,ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT),start.length=0;const[x,O]=inverseCoords([e,a]);if(start.push(x,O),COLUMNS.forEach((e,a,E)=>{const n=a;a*=TILE_WIDTH,COORDINATES[a]={},ROWS.forEach((e,E,t)=>{const T=x==a&&O==E,I=E;E*=TILE_HEIGHT;const l=Math.random(),r=x===a&&O===E;COORDINATES[a][E]={hasBeenSeen:0,inSight:0,quadrant:a>=xyMax/2&&E<=xyMax/2?1:a<=xyMax/2&&E<=xyMax/2?2:a<=xyMax/2&&E>=xyMax/2?3:4,corner:0==a&&0==E||0==a&&E==xyMax||a==xyMax&&E==xyMax||a==xyMax&&0==E?1:0},0==n||0==I||E==xyMax||a==xyMax?(COORDINATES[a][E].walkable=x==a&&O==E?1:0,T?COORDINATES[a][E].start=1:COORDINATES[a][E].border=1):a<xyMax&&E<xyMax?(COORDINATES[a][E].walkable=l<=WALKABLE_TILE_CHANCE||r?1:0,COORDINATES[a][E].walkable?walkableTiles++:COORDINATES[a][E].occupied=1):COORDINATES[a][E].corner&&(COORDINATES[a][E].walkable=0)})}),exit=generateRandomEndpoint([x,O],TILE_HEIGHT),COORDINATES[exit[0]][exit[1]].walkable=1,COORDINATES[exit[0]][exit[1]].exit=1,!checker([x,O]))return buildDungeon([e,a]);generatePlayer([x,O],COORDINATES,TILE_HEIGHT),generateEnemies(lvl,xyMax,COORDINATES),dungeon++};